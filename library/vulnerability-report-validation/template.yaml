apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: vulnerabilityreportvalidation
spec:
  crd:
    spec:
      names:
        kind: VulnerabilityReportValidation
      validation:
        openAPIV3Schema:
          type: object
          properties:
            issuer:
              type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package vulnerabilityreportvalidation

        import future.keywords.if
        import future.keywords.in
        import future.keywords.every

        default supported_types := {"trivy", "grype"}
        default disallowed_severity := {"high", "critical"}
        default severity_regex := `Severity:\s*(\w+)`

        # Get data from Ratify
        remote_data := response {
          images := [img | img = input.review.object.spec.containers[_].image]
          images_init := [img | img = input.review.object.spec.initContainers[_].image]
          images_ephemeral := [img | img = input.review.object.spec.ephemeralContainers[_].image]
          other_images := array.concat(images_init, images_ephemeral)
          all_images := array.concat(other_images, images)
          response := external_data({"provider": "ratify-provider", "keys": all_images})
        }

        violation[{"msg": msg}] {
          general_violation[{"result": msg}]
        }

        # Check if there are any system errors
        general_violation[{"result": result}] {
          test_output = {"hello": "hi"}
          err := remote_data.system_error
          err != ""
          result := sprintf("System error calling external data provider: %s", [err])
        }
        # Check if there are errors for any of the images
        general_violation[{"result": result}] {
          count(remote_data.errors) > 0
          result := sprintf("Error validating one or more images: %s", remote_data.errors)
        }

        # Check if the success criteria is true
        general_violation[{"result": result}] {
          subject_validation := remote_data.responses[_]
          subject_result := subject_validation[1]
          vuln_results := [res | subject_result.verifierReports[i].name == "vulnerabilityreport"; res := subject_result.verifierReports[i]]
          not process_vuln_reports(vuln_results)
          result := sprintf("Subject failed verification: %s", [subject_validation[0]])
        }

        process_vuln_reports(reports) if {
          # ALL reports must be valid
          every vuln_report in reports {
            raw_report := vuln_report.extensions.report
            json_report := json.unmarshal(raw_report)
            # check valid json_report in SARIF based on scanner type
            is_report_valid(json_report)
            # find matching rule per result
            every result in json_report.runs[0].results {
              some i
              json_report.runs[0].tool.driver.rules[i].id == result.ruleId
              json_report.runs[0].tool.driver.rules[i].help.text
              # extract severity
              severity := lower(regex.find_all_string_submatch_n(severity_regex, json_report.runs[0].tool.driver.rules[i].help.text, 1)[0][1])
              severity
              # severity should not exist in disallowed list
              count({severity} & disallowed_severity) == 0
            }
          }
        }

        is_report_valid(report) if {
          # check scanner name exists
          report.runs[0].tool.driver.name
          # check report is from a support scanner
          count({lower(report.runs[0].tool.driver.name)} & supported_types) > 0
          # check results field exist (0 length ok)
          report.runs[0].results
        }