/*
Copyright The Ratify Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"regexp"
	"strings"
	"time"

	"github.com/deislabs/ratify/pkg/common"
	"github.com/deislabs/ratify/pkg/ocispecs"
	"github.com/deislabs/ratify/pkg/referrerstore"
	_ "github.com/deislabs/ratify/pkg/referrerstore/oras"
	"github.com/deislabs/ratify/pkg/verifier"
	"github.com/deislabs/ratify/pkg/verifier/plugin/skel"
	"github.com/deislabs/ratify/plugins/verifier/schemavalidator/schemavalidation"
	imagespec "github.com/opencontainers/image-spec/specs-go/v1"
	"github.com/owenrumney/go-sarif/v2/sarif"
)

const (
	SarifMediaType        string = "application/sarif+json"
	TrivyScannerName      string = "trivy"
	GrypeScannerName      string = "grype"
	CreatedAnnotation     string = imagespec.AnnotationCreated
	DefaultSarifSchemaURL string = "https://json.schemastore.org/sarif-2.1.0.json"
	SeverityRegex                = `Severity:\s*(\w+)`
)

type PluginConfig struct {
	Name               string   `json:"name"`
	SarifSchemaURL     string   `json:"schemas,omitempty"`
	MaximumAge         string   `json:"maximumAge,omitempty"`
	DisallowedSeverity []string `json:"disallowedSeverity,omitempty"`
	Passthrough        bool     `json:"passthrough,omitempty"`
}

type PluginInputConfig struct {
	Config PluginConfig `json:"config"`
}

func main() {
	skel.PluginMain("vulnerabilityreport", "1.0.0", VerifyReference, []string{"1.0.0"})
}

func parseInput(stdin []byte) (*PluginConfig, error) {
	conf := PluginInputConfig{}

	if err := json.Unmarshal(stdin, &conf); err != nil {
		return nil, fmt.Errorf("failed to parse stdin for the input: %w", err)
	}

	return &conf.Config, nil
}

func VerifyReference(args *skel.CmdArgs, subjectReference common.Reference, referenceDescriptor ocispecs.ReferenceDescriptor, referrerStore referrerstore.ReferrerStore) (*verifier.VerifierResult, error) {
	input, err := parseInput(args.StdinData)
	if err != nil {
		return nil, err
	}

	// check report is newer than allowed maximum age
	if input.MaximumAge != "" {
		ok, created, err := validateMaximumAge(input.MaximumAge, referenceDescriptor)
		if err != nil {
			return &verifier.VerifierResult{
				Name:      input.Name,
				IsSuccess: false,
				Message:   fmt.Sprintf("vulnerability report validation failed: error validating maximum age:[%v]", err.Error()),
			}, nil
		}
		if !ok {
			return &verifier.VerifierResult{
				Name:      input.Name,
				IsSuccess: false,
				Message:   fmt.Sprintf("vulnerability report validation failed: report is older than maximum age:[%s]", input.MaximumAge),
				Extensions: map[string]interface{}{
					CreatedAnnotation: created,
				},
			}, nil
		}
	}

	ctx := context.Background()

	referenceManifest, err := referrerStore.GetReferenceManifest(ctx, subjectReference, referenceDescriptor)
	if err != nil {
		return nil, fmt.Errorf("error fetching reference manifest for subject: %s reference descriptor: %v", subjectReference, referenceDescriptor.Descriptor)
	}

	if len(referenceManifest.Blobs) == 0 {
		return &verifier.VerifierResult{
			Name:      input.Name,
			IsSuccess: false,
			Message:   fmt.Sprintf("vulnerability report validation failed: no blobs found for referrer %s@%s", subjectReference.Path, referenceDescriptor.Digest.String()),
		}, nil
	}

	blobDesc := referenceManifest.Blobs[0]
	refBlob, err := referrerStore.GetBlobContent(ctx, subjectReference, blobDesc.Digest)
	if err != nil {
		return nil, fmt.Errorf("error fetching blob for subject:[%s] digest:[%s]", subjectReference, blobDesc.Digest)
	}

	err = processMediaType(blobDesc.MediaType, refBlob, input.SarifSchemaURL)
	if err != nil {
		return &verifier.VerifierResult{
			Name:      input.Name,
			IsSuccess: false,
			Message:   fmt.Sprintf("vulnerability report validation failed: schema validation failed for digest:[%s],media type:[%s],parse errors:[%v]", blobDesc.Digest, blobDesc.MediaType, err.Error()),
		}, nil
	}

	// skip severity validation if passthrough is enabled
	if input.Passthrough {
		return &verifier.VerifierResult{
			Name:      input.Name,
			IsSuccess: false,
			Message:   "vulnerability report validation skipped",
			Extensions: map[string]interface{}{
				"passthrough": true,
				"report":      string(refBlob),
			},
		}, nil
	}

	if blobDesc.MediaType == SarifMediaType && len(input.DisallowedSeverity) > 0 {
		return processSarifReport(input.Name, refBlob, input.DisallowedSeverity)
	}

	return &verifier.VerifierResult{
		Name:      input.Name,
		IsSuccess: true,
		Message:   "vulnerability report validation succeeded",
	}, nil
}

func processMediaType(mediaType string, refBlob []byte, sarifSchemaURL string) error {
	if mediaType == SarifMediaType {
		// decide online or offline schema type
		if sarifSchemaURL != "" {
			return schemavalidation.Validate(sarifSchemaURL, refBlob)
		}
		return schemavalidation.Validate(DefaultSarifSchemaURL, refBlob)
	}
	return fmt.Errorf("media type not configured for plugin:[%s]", mediaType)
}

func processSarifReport(verifierName string, blob []byte, disallowedSeverity []string) (*verifier.VerifierResult, error) {
	sarifReport, err := sarif.FromBytes(blob)
	if err != nil {
		return &verifier.VerifierResult{
			Name:      verifierName,
			IsSuccess: false,
			Message:   fmt.Sprintf("vulnerability report validation failed: error parsing sarif report:[%v]", err.Error()),
		}, nil
	}
	// verify that there is at least one run in the report
	if len(sarifReport.Runs) < 1 {
		return &verifier.VerifierResult{
			Name:      verifierName,
			IsSuccess: false,
			Message:   "vulnerability report validation failed: no runs found in sarif report",
		}, nil
	}
	scannerName := strings.ToLower(sarifReport.Runs[0].Tool.Driver.Name)
	ruleMap := make(map[string]*sarif.ReportingDescriptor)
	violatingRules := make([]sarif.ReportingDescriptor, 0)
	// create a map of rule id to rule for easy lookup
	for _, rule := range sarifReport.Runs[0].Tool.Driver.Rules {
		ruleMap[rule.ID] = rule
	}
	// iterate over the results and check if the severity is disallowed
	for _, result := range sarifReport.Runs[0].Results {
		if result.RuleID == nil || *result.RuleID == "" {
			return &verifier.VerifierResult{
				Name:      verifierName,
				IsSuccess: false,
				Message:   fmt.Sprintf("vulnerability report validation failed: rule id not found for result:[%v]", result),
				Extensions: map[string]interface{}{
					"scanner": scannerName,
				},
			}, nil
		}
		rule, ok := ruleMap[*result.RuleID]
		if !ok {
			return &verifier.VerifierResult{
				Name:      verifierName,
				IsSuccess: false,
				Message:   fmt.Sprintf("vulnerability report validation failed: rule not found for result:[%v]", result),
				Extensions: map[string]interface{}{
					"scanner": scannerName,
				},
			}, nil
		}
		severity, err := extractSeverity(scannerName, *rule)
		if err != nil {
			return &verifier.VerifierResult{
				Name:      verifierName,
				IsSuccess: false,
				Message:   fmt.Sprintf("vulnerability report validation failed: error extracting severity:[%v]", err.Error()),
				Extensions: map[string]interface{}{
					"scanner": scannerName,
				},
			}, nil
		}
		if severity == "" {
			return &verifier.VerifierResult{
				Name:      verifierName,
				IsSuccess: false,
				Message:   fmt.Sprintf("vulnerability report validation failed: severity not found for result:[%v]", result),
				Extensions: map[string]interface{}{
					"scanner": scannerName,
				},
			}, nil
		}
		// check if the severity is disallowed and add it to the list of violating rules
		for _, disallowed := range disallowedSeverity {
			if strings.EqualFold(severity, disallowed) {
				violatingRules = append(violatingRules, *rule)
			}
		}
	}
	// if there are violating rules, return them as custom extension field
	if len(violatingRules) > 0 {
		return &verifier.VerifierResult{
			Name:      verifierName,
			IsSuccess: false,
			Extensions: map[string]interface{}{
				"scanner":            scannerName,
				"severityViolations": violatingRules,
			},
			Message: "vulnerability report validation failed",
		}, nil
	}
	return &verifier.VerifierResult{
		Name:      verifierName,
		IsSuccess: true,
		Message:   "vulnerability report validation succeeded",
		Extensions: map[string]interface{}{
			"scanner": scannerName,
		},
	}, nil
}

func extractSeverity(scannerName string, rule sarif.ReportingDescriptor) (string, error) {
	if scannerName == TrivyScannerName || scannerName == GrypeScannerName {
		if rule.Help == nil || rule.Help.Text == nil || *rule.Help.Text == "" {
			return "", fmt.Errorf("help text not found for rule:[%s]", rule.ID)
		}
		re := regexp.MustCompile(SeverityRegex)
		match := re.FindStringSubmatch(*rule.Help.Text)
		if len(match) < 2 {
			return "", fmt.Errorf("severity not found in help text:[%s]", *rule.Help.Text)
		}
		return strings.ToLower(match[1]), nil
	}
	return "", fmt.Errorf("scanner not supported:[%s]", scannerName)
}

func validateMaximumAge(maximumAge string, descriptor ocispecs.ReferenceDescriptor) (bool, string, error) {
	// check if annotations exist
	if descriptor.Annotations == nil {
		return false, "", fmt.Errorf("no annotations found for descriptor:[%v]", descriptor)
	}
	// check if created annotation exists
	created, ok := descriptor.Annotations[CreatedAnnotation]
	if !ok {
		return false, "", fmt.Errorf("created annotation not found for descriptor:[%v]", descriptor)
	}
	// check if created annotation is a valid timestamp
	createdTime, err := time.Parse(time.RFC3339, created)
	if err != nil {
		return false, "", fmt.Errorf("error parsing created timestamp:[%s]", created)
	}
	// check if maxium age is a valid duration
	duration, err := time.ParseDuration(maximumAge)
	if err != nil {
		return false, "", fmt.Errorf("error parsing maximum age:[%s]", maximumAge)
	}
	// check if created timestamp is older than maximum age
	if time.Since(createdTime) > duration {
		return false, created, nil
	}

	return true, created, nil
}
